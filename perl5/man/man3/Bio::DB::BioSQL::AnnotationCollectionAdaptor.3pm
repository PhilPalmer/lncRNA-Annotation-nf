.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::BioSQL::AnnotationCollectionAdaptor 3"
.TH Bio::DB::BioSQL::AnnotationCollectionAdaptor 3 "2016-05-27" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::BioSQL::AnnotationCollectionAdaptor \- DESCRIPTION of Object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Give standard usage here
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Describe the object here
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this
and other Bioperl modules. Send your comments and suggestions preferably
to one of the Bioperl mailing lists.
Your participation is much appreciated.
.PP
.Vb 1
\&  bioperl\-l@bio.perl.org
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution. Bug reports can be submitted via the web:
.PP
.Vb 1
\&  http://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Ewan Birney, Hilmar Lapp"
.IX Header "AUTHOR - Ewan Birney, Hilmar Lapp"
Email birney@ebi.ac.uk
Email hlapp at gmx.net
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods. 
Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 5
\& Title   : new
\& Usage   : my $obj = Bio::DB::BioSQL::AnnotationCollectionAdaptor\->new();
\& Function: Builds a new Bio::DB::BioSQL::AnnotationCollectionAdaptor object 
\& Returns : an instance of Bio::DB::BioSQL::AnnotationCollectionAdaptor
\& Args    :
.Ve
.SS "get_foreign_key_objects"
.IX Subsection "get_foreign_key_objects"
.Vb 4
\& Title   : get_foreign_key_objects
\& Usage   :
\& Function: Gets the objects referenced by this object, and which therefore need
\&           to be referenced as foreign keys in the datastore.
\&
\&           Note that the objects are expected to implement
\&           Bio::DB::PersistentObjectI.
\&
\&           An implementation may obtain the values either through the
\&           object to be serialized, or through the additional
\&           arguments. An implementation should also make sure that the
\&           order of foreign key objects returned is always the same.
\&
\& Example :
\& Returns : an array of Bio::DB::PersistentObjectI implementing objects
\& Args    : The object about to be inserted or updated, or undef if the call
\&           is for a SELECT query. In the latter case return class or interface
\&           names that are mapped to the foreign key tables.
\&           Optionally, additional named parameters. A common parameter will
\&           be \-fkobjs, with a reference to an array of foreign key objects
\&           that are not retrievable from the persistent object itself.
.Ve
.SS "store_children"
.IX Subsection "store_children"
.Vb 10
\& Title   : store_children
\& Usage   :
\& Function: Inserts or updates the child entities of the given object in the 
\&           datastore.
\& Example :
\& Returns : TRUE on success, and FALSE otherwise
\& Args    : The Bio::DB::PersistentObjectI implementing object for which the
\&           child objects shall be made persistent.
\&           A reference to an array of foreign key values, in the order of
\&           foreign keys returned by get_foreign_key_objects().
.Ve
.SS "attach_children"
.IX Subsection "attach_children"
.Vb 3
\& Title   : attach_children
\& Usage   :
\& Function: Possibly retrieve and attach child objects of the given object.
\&
\&           This is called by the find_by_XXXX() methods once the base
\&           object has been built.
\&
\& Example :
\& Returns : TRUE on success, and FALSE otherwise.
\& Args    : The object for which to find and to which to attach the child
\&           objects.
\&           Foreign key objects by which to find the entries to be attached
\&           (as an array ref).
.Ve
.SH "Inherited methods"
.IX Header "Inherited methods"
.Vb 4
\& We override a couple of inherited methods here because an
\& AnnotationCollection currently is only a virtual entity in the
\& database. Hence, a number of operations greatly reduce or don\*(Aqt make
\& sense at all.
.Ve
.SS "remove"
.IX Subsection "remove"
.Vb 7
\& Title   : remove
\& Usage   : $objectstoreadp\->remove($persistent_obj, @params)
\& Function: Removes the persistent object from the datastore.
\& Example :
\& Returns : TRUE on success and FALSE otherwise
\& Args    : The object to be removed, and optionally additional (named) 
\&           parameters.
.Ve
.SS "find_by_primary_key"
.IX Subsection "find_by_primary_key"
.Vb 4
\& Title   : find_by_primary_key
\& Usage   : $objectstoreadp\->find_by_primary_key($pk)
\& Function: Locates the entry associated with the given primary key and
\&           initializes a persistent object with that entry.
\&
\&           AnnotationCollection is not an entity in the database and hence
\&           this method doesn\*(Aq\*(Aqt make sense. We just throw an exception here.
\& Example :
\& Returns : 
\& Args    :
.Ve
.SS "find_by_unique_key"
.IX Subsection "find_by_unique_key"
.Vb 4
\& Title   : find_by_unique_key
\& Usage   :
\& Function: Locates the entry matching the unique key attributes as set in the
\&           passed object, and populates a persistent object with this entry.
\&
\&           AnnotationCollection is not an entity in the database and hence
\&           this method doesn\*(Aq\*(Aqt make sense. We just throw an exception here.
\& Example :
\& Returns : 
\& Args    :
.Ve
.SS "add_association"
.IX Subsection "add_association"
.Vb 3
\& Title   : add_assocation
\& Usage   :
\& Function: Stores the association between given objects in the datastore.
\&
\&           We override this here in order to propagate associations of the
\&           AnnotationCollection to all the annotations it contains.
\& Example :
\& Returns : TRUE on success and FALSE otherwise
\& Args    : Named parameters. At least the following must be recognized:
\&               \-objs   a reference to an array of objects to be associated with
\&                       each other
\&               \-values a reference to a hash the keys of which are abstract
\&                       column names and the values are values of those columns.
\&                       These columns are generally those other than
\&                       the ones for foreign keys to the entities to be
\&                       associated
\&  Caveats: Make sure you *always* give the objects to be associated in the
\&           same order.
.Ve
.SS "find_by_association"
.IX Subsection "find_by_association"
.Vb 6
\& Title   : find_by_association
\& Usage   :
\& Function: Locates those records associated between a number of
\&           objects. The focus object (the type to be instantiated)
\&           depends on the adaptor class that inherited from this
\&           class.
\&
\&           We override this here to propagate this to all possible
\&           annotations.
\&
\& Example :
\& Returns : A Bio::DB::Query::QueryResultI implementing object 
\& Args    : Named parameters. At least the following must be recognized:
\&               \-objs   a reference to an array of objects to be
\&                       associated with each other
\&               \-obj_factory the factory to use for instantiating the
\&                       AnnotationCollectionI implementation.
\&  Caveats: Make sure you *always* give the objects to be associated in
\&           the same order.
.Ve
.SS "remove_children"
.IX Subsection "remove_children"
.Vb 3
\& Title   : remove_children
\& Usage   :
\& Function: This method is to cascade deletes in maintained objects.
\&
\&           We need to undefine the primary keys of all contained
\&           children objects here.
\&
\& Example :
\& Returns : TRUE on success and FALSE otherwise
\& Args    : The persistent object that was just removed from the database.
\&           Additional (named) parameter, as passed to remove().
.Ve
.SH "Internal Methods"
.IX Header "Internal Methods"
.Vb 4
\& These are mostly private or \*(Aqprotected.\*(Aq Methods which are in the
\& latter class have this explicitly stated in their
\& documentation. \*(AqProtected\*(Aq means you may call these from derived
\& classes, but not from outside.
\&
\& Most of these methods cache certain adaptors or otherwise reduce call
\& path and object creation overhead. There\*(Aqs no magic here.
.Ve
.SS "_anntype_assoc_args"
.IX Subsection "_anntype_assoc_args"
.Vb 5
\& Title   : _anntype_assoc_args
\& Usage   :
\& Function: Get the arguments to be passed to the annotation object
\&           adaptor\*(Aq\*(Aqs add_association method, based on the type of
\&           annotation to be associated.
\&
\&           This is an internal method.
\&
\& Example :
\& Returns : an array of arguments in the format of named parameters
\& Args    : the adaptor for the annotation object
\&           the type of the annotation object (a string)
.Ve
.SS "_supported_annotation_map"
.IX Subsection "_supported_annotation_map"
.Vb 4
\& Title   : _supported_annotation_map
\& Usage   : $obj\->_supported_annotation_map($newval)
\& Function: Get/set the map of supported annotation types (implementing
\&           classes) to annotation keys and persistence arguments.
\&
\&           The values of the map are anonymous hashes themselves with
\&           currently the following keys and values.
\&             key     the annotation collection key for this type of
\&                     annotation
\&             link    the type of link between the collection and the
\&                     annotation object (child or association)
\&
\& Example : 
\& Returns : value of _supported_annotation_map (a reference to hash map)
\& Args    : new value (a reference to a hash map)
.Ve
