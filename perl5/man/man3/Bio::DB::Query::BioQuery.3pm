.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::Query::BioQuery 3"
.TH Bio::DB::Query::BioQuery 3 "2016-05-27" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::Query::BioQuery \- Object representing a query on a bioperldb
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  # generally
\&  $q = Bio::DB::Query::BioQuery\->new;
\&  $q\->where(["AND", "attA=x", "attB=y", "attC=y"]);
\&  $adaptor\->fetch_by_query($q);
\&
\&  # more specific example in the context of biosql:
\&  $query = Bio::DB::Query::BioQuery\->new();
\&
\&  # all mouse sequences loaded under namespace ensembl that
\&  # have receptor in their description
\&  $query\->datacollections(["Bio::PrimarySeqI e",
\&                         "Bio::Species => Bio::PrimarySeqI sp",
\&                         "BioNamespace => Bio::PrimarySeqI db"]);
\&  $query\->where(["sp.binomial like \*(AqMus *\*(Aq",
\&                      "e.desc like \*(Aq*receptor*\*(Aq",
\&                 "db.namespace = \*(Aqensembl\*(Aq"]);
\&
\&  # all mouse sequences loaded under namespace ensembl that
\&  # have receptor in their description, and that also have a
\&  # cross\-reference with SWISS as the database
\&  $query\->datacollections(["Bio::PrimarySeqI e",
\&                         "Bio::Species => Bio::PrimarySeqI sp",
\&                         "BioNamespace => Bio::PrimarySeqI db",
\&                         "Bio::Annotation::DBLink xref",
\&                         "Bio::PrimarySeqI <=> Bio::Annotation::DBLink"]);
\&  $query\->where(["sp.binomial like \*(AqMus *\*(Aq",
\&                      "e.desc like \*(Aq*receptor*\*(Aq",
\&                      "db.namespace = \*(Aqensembl\*(Aq",
\&                      "xref.database = \*(AqSWISS\*(Aq"]);
\&
\&  # find a bioentry by primary key
\&  $query\->datacollections(["Bio::PrimarySeqI]);
\&  $query\->where(["Bio::PrimarySeqI::primary_key = 10"]);
\&
\&  # all bioentries in a sequence cluster (Hs.2 as an example)
\&  $query\->datacollections(
\&                  ["Bio::PrimarySeqI c::subject",
\&                   "Bio::PrimarySeqI p::object",
\&                   "Bio::PrimarySeqI<=>Bio::ClusterI<=>Bio::Ontology::TermI"]);
\&  $query\->where(["p.accession_number = \*(AqHs.2\*(Aq",
\&                 "Bio::Ontology::TermI::name = \*(Aqcluster member\*(Aq"]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A BioQuery is a high level query on a biological database. It allows
queries to be specified regardless of the underlying schema. Although
a BioQuery can be translated into a corresponding \s-1SQL\s0 query or series
of \s-1SQL\s0 queries, it is not always desirable to do so; rather the BioQuery
should be translated into \s-1SQL\s0 querys one at a time, the \s-1SQL\s0 query
executed and the results fed back to the BioQuery processor.
.PP
It is the job of the various adaptors to turn BioQuerys into resulting
Bio objects via these transformations.
.PP
A BioQuery can be specified either as a text string which is converted
into a BioQuery object via some grammar, or the object can be created
and manipulated directly. The text string would be some kind of
language like \s-1SQL\s0, one can imagine different languages with different
grammars.
.PP
Other than being more high level, a BioQuery differs from a \s-1SQL\s0 Query
in that it is object based, not table based.
.PP
The BioQuery is a schema-independent representation of a query; it may
or may not be tied to the bioperl object model.
.SH "STATUS"
.IX Header "STATUS"
There is no parser to turn statements like
.PP
.Vb 1
\&  "FETCH Seq.* from Seq where species=\*(AqHuman\*(Aq"
.Ve
.PP
into a BioQuery object; objects have to be built manually
.PP
At the moment, everything in this object apart from the query
constraints (the \f(CW$bioquery\fR\->\fIwhere()\fR method) are ignored.
.SH "CONTACT"
.IX Header "CONTACT"
Chris Mungall, cmungall@fruitfly.org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods. Internal 
methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 2
\&  Usage:  $bioq = $self\->new(\-select => ["att1", "att2"],
\&                                            \-where  => ["att3=\*(Aqval1\*(Aq", "att4=\*(Aqval4\*(Aq"]);
\&
\&      OR  $bioq = $self\->new(\-where => {species=>\*(Aqhuman\*(Aq});
\&
\&          # NOT IMPLEMENTED:
\&          $bioq = $self\->new("SELECT bioentry.* FROM bioentry WHERE species=\*(AqHuman\*(Aq");  
\&
\&  Args: objects, where, select, order, group
\&
\&        All arguments are optional (select defaults to *).
\&
\&        The arguments can either be array references or a comma delimited string.
\&
\&        The where argument can also be passed as a hash reference.
\&
\&        The from/objects array is optional because this is usually derived
\&        from the context eg the database adapter used. if used outside this
\&        context the object is required.
.Ve
.SS "translate_query"
.IX Subsection "translate_query"
.Vb 4
\& Title   : translate_query
\& Usage   :
\& Function: Translates this query from objects and class names and
\&           slot names to tables and column names.
\&
\&           You will most likely have to call this method before being
\&           able to generate meaningful SQL from a BioQuery object.
\&
\& Example :
\& Returns : An object of the same class as this query, but representing
\&           the translated query.
\& Args    : The L<Bio::DB::Persistent::ObjectRelMapperI> to use.
\&           Optionally, a reference to an empty hash. If provided, upon
\&           return it will hold a mapping from tables to aliases.
.Ve
.PP
Contact Hilmar Lapp, hlapp at gmx.net, for questions, bugs, flames,
praises etc.
.PP
Off records, this implementation has grown hideous. It needs to be
rewritten. The problem is, it''s not an easy task, and it works
currently as far as I can tell ...
