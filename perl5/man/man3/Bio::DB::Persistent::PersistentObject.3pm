.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::Persistent::PersistentObject 3"
.TH Bio::DB::Persistent::PersistentObject 3 "2016-05-27" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::Persistent::PersistentObject \- makes a given object persistent
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # obtain a PersistentObject somehow, e.g.
\&    $pobj = $dbadaptor\->create_persistent("Bio::Seq");
\&
\&    # manipulate and query as if it were the wrapped object itself
\&    print $pobj\->isa("Bio::PrimarySeqI"), "\en";
\&    $pobj\->display_id("O238356");
\&    $pobj\->seq("ATCATCGACTGACAGGCAGTATCGACTAGCA");
\&    $fea = Bio::SeqFeature::Generic\->new(\-start => 3, \-end => 15);
\&    $fea\->attach_seq($pobj);
\&    # and so on and so forth
\&
\&    # and, finally, or whenever suitable, make it persistent in the datastore
\&    $pobj\->create();
\&    # change it
\&    $pobj\->desc("not a useful description");
\&    # and update it in the datastore
\&    $pobj\->store();
\&
\&    # you may also want it to disappear
\&    $pobj\->remove();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class takes any Bioperl object for which an adaptor exists for a certain
datastore and makes it implement Bio::DB::PersistentObjectI.
.PP
There is one single caveat though. The wrapped object must not use any of the
method names defined in Bio::DB::PersistentObjectI, nor \fIobj()\fR or \fIadaptor()\fR.
If it does, calls of these methods will never get routed to the wrapped object.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via
the web:
.PP
.Vb 1
\&  http://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Hilmar Lapp"
.IX Header "AUTHOR - Hilmar Lapp"
Email hlapp at gmx.net
.PP
Describe contact details here
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Additional contributors names and emails here
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 6
\& Title   : new
\& Usage   : my $obj = Bio::DB::Persistent::PersistentObject\->new();
\& Function: Builds a new Bio::DB::Persistent::PersistentObject object 
\& Returns : an instance of Bio::DB::Persistent::PersistentObject
\& Args    : \-object => $obj_to_be_wrapped (mandatory)
\&           \-adaptor => $adaptor_for_obj (optional, may be set later)
.Ve
.SS "create"
.IX Subsection "create"
.Vb 4
\& Title   : create
\& Usage   : $obj\->create()
\& Function: Creates the object as a persistent object in the datastore. This
\&           is equivalent to an insert.
\&
\&           Note that you will be able to retrieve the primary key at any time
\&           by calling primary_key() on the object.
\& Example :
\& Returns : The newly assigned primary key.
\& Args    : Optionally, additional named parameters. A common parameter will
\&           be \-fkobjs, with a reference to an array of foreign key objects
\&           that are not retrievable from the persistent object itself.
.Ve
.SS "store"
.IX Subsection "store"
.Vb 9
\& Title   : store
\& Usage   : $obj\->store()
\& Function: Updates the persistent object in the datastore to reflect its
\&           attribute values.
\& Example :
\& Returns : TRUE on success and FALSE otherwise
\& Args    : Optionally, additional named parameters. A common parameter will
\&           be \-fkobjs, with a reference to an array of foreign key objects
\&           that are not retrievable from the persistent object itself.
.Ve
.SS "remove"
.IX Subsection "remove"
.Vb 6
\& Title   : remove
\& Usage   : $obj\->remove()
\& Function: Removes the persistent object from the datastore.
\& Example :
\& Returns : TRUE on success and FALSE otherwise
\& Args    : none
.Ve
.SS "primary_key"
.IX Subsection "primary_key"
.Vb 3
\& Title   : primary_key
\& Usage   : $obj\->primary_key($newval)
\& Function: Get the primary key of the persistent object in the datastore.
\&
\&           Note that this implementation does not permit changing the
\&           primary key once it has been set. This is for sanity
\&           reasons, and may or may not be relaxed in the future. The
\&           only exception is changing it to undef.
\&
\& Example : 
\& Returns : value of primary_key (a scalar)
\& Args    : new value (a scalar, optional)
.Ve
.SS "obj"
.IX Subsection "obj"
.Vb 3
\& Title   : obj
\& Usage   : $obj\->obj()
\& Function: Get/set the object that is made persistent through this adaptor.
\&
\&           Note that this implementation does not allow to change the
\&           value once it has been set. This is for sanity reasons, and
\&           may or may not be relaxed in the future.
\&
\& Example : 
\& Returns : The object made persistent through this adaptor
\& Args    : On set, the new value. Read above for caveat.
.Ve
.SS "adaptor"
.IX Subsection "adaptor"
.Vb 7
\& Title   : adaptor
\& Usage   : $obj\->adaptor($newval)
\& Function: Get/set of the PersistenceAdaptorI compliant object that actually
\&           implements persistence for this object
\& Example : 
\& Returns : A Bio::DB::PersistenceAdaptorI compliant object
\& Args    : Optionally, on set a Bio::DB::PersistenceAdaptorI compliant object
.Ve
.SS "is_dirty"
.IX Subsection "is_dirty"
.Vb 4
\& Title   : is_dirty
\& Usage   : $obj\->is_dirty($newval)
\& Function: Get/set whether this persistent object is to be considered
\&           dirty.
\&
\&           An object is considered dirty if one or more of it\*(Aqs
\&           properties has been altered since it was last obtained
\&           from, stored in, or created in the database, or if the
\&           create() (insert) or the last store() (update) hasn\*(Aqt been
\&           committed or rolled back yet.
\&
\&           There are currently 3 known states of this attribute. A
\&           value of zero (or false) means the object has not been
\&           modified since it either came from the database, or since
\&           the changes have been serialized (via store()) and
\&           committed (via commit()). A negative value means changes
\&           have been serialized, but not yet committed. A positive
\&           value means there have been unserialized changes on the
\&           object.
\&
\& Example : 
\& Returns : value of is_dirty (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SH "Methods for transactional control"
.IX Header "Methods for transactional control"
.Vb 1
\&   Rollback and commit
.Ve
.SS "commit"
.IX Subsection "commit"
.Vb 7
\& Title   : commit
\& Usage   :
\& Function: Commits the current transaction, if the underlying driver
\&           supports transactions.
\& Example :
\& Returns : TRUE
\& Args    : none
.Ve
.SS "rollback"
.IX Subsection "rollback"
.Vb 7
\& Title   : rollback
\& Usage   :
\& Function: Triggers a rollback of the current transaction, if the
\&           underlying driver supports transactions.
\& Example :
\& Returns : TRUE
\& Args    : none
.Ve
.SH "Methods to mimic the wrapped object"
.IX Header "Methods to mimic the wrapped object"
.SS "isa"
.IX Subsection "isa"
.Vb 9
\& Title   : isa
\& Usage   :
\& Function: This is a standard perl object method. We override it here in order
\&           to generically claim we implement everything that the wrapped
\&           object does.
\& Example :
\& Returns : TRUE if this object is an instance of the given class, or inherits
\&           from the given class, and FALSE otherwise
\& Args    : the class to query for (a scalar string)
.Ve
.SS "can"
.IX Subsection "can"
.Vb 8
\& Title   : can
\& Usage   :
\& Function: This is a standard perl object method. We override it here in order
\&           to generically claim we \*(Aqcan\*(Aq everything that the wrapped
\&           object does.
\& Example :
\& Returns : TRUE if this object is has the named method, and FALSE otherwise
\& Args    : the method to query for (a scalar string)
.Ve
.SH "Implementation of the decorating methods"
.IX Header "Implementation of the decorating methods"
See Bio::DB::PersistentObjectI for further documentation of the
methods.
.SS "rank"
.IX Subsection "rank"
.Vb 4
\& Title   : rank
\& Usage   : $obj\->rank($newval)
\& Function: Get/set the rank of this persistent object in a 1:n or n:n
\&           relationship.
\&
\& Example : 
\& Returns : value of rank (a scalar)
\& Args    : new value (a scalar or undef, optional)
.Ve
.SS "foreign_key_slot"
.IX Subsection "foreign_key_slot"
.Vb 4
\& Title   : foreign_key_slot
\& Usage   : $obj\->foreign_key_slot($newval)
\& Function: Get/set of the slot name that is referring to this persistent
\&           object as a foreign key.
\&
\& Example : 
\& Returns : value of foreign_key_slot (a scalar)
\& Args    : new value (a scalar or undef, optional)
.Ve
