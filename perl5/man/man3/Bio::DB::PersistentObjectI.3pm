.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::PersistentObjectI 3"
.TH Bio::DB::PersistentObjectI 3 "2016-05-27" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::PersistentObjectI \- DESCRIPTION of Interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Give standard usage here
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Describe the interface here
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via
the web:
.PP
.Vb 1
\&  http://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Hilmar Lapp"
.IX Header "AUTHOR - Hilmar Lapp"
Email hlapp at gmx.net
.PP
Describe contact details here
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Additional contributors names and emails here
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SH "Methods for managing persistence of this object"
.IX Header "Methods for managing persistence of this object"
.Vb 2
\&   Create (insert), store (update), remove (delete), and the primary
\&   key
.Ve
.SS "create"
.IX Subsection "create"
.Vb 4
\& Title   : create
\& Usage   : $obj\->create()
\& Function: Creates the object as a persistent object in the datastore. This
\&           is equivalent to an insert.
\&
\&           Note that you will be able to retrieve the primary key at any time
\&           by calling primary_key() on the object.
\& Example :
\& Returns : The newly assigned primary key.
\& Args    : Optionally, additional named parameters. A common parameter will
\&           be \-fkobjs, with a reference to an array of foreign key objects
\&           that are not retrievable from the persistent object itself.
.Ve
.SS "store"
.IX Subsection "store"
.Vb 9
\& Title   : store
\& Usage   : $obj\->store()
\& Function: Updates the persistent object in the datastore to reflect its
\&           attribute values.
\& Example :
\& Returns : TRUE on success and FALSE otherwise
\& Args    : Optionally, additional named parameters. A common parameter will
\&           be \-fkobjs, with a reference to an array of foreign key objects
\&           that are not retrievable from the persistent object itself.
.Ve
.SS "remove"
.IX Subsection "remove"
.Vb 6
\& Title   : remove
\& Usage   : $obj\->remove()
\& Function: Removes the persistent object from the datastore.
\& Example :
\& Returns : TRUE on success and FALSE otherwise
\& Args    : none
.Ve
.SS "primary_key"
.IX Subsection "primary_key"
.Vb 3
\& Title   : primary_key
\& Usage   : $obj\->primary_key($newval)
\& Function: Get the primary key of the persistent object in the datastore.
\&
\&           Note that an implementation may not permit changing the
\&           primary key once it has been set. For most applications,
\&           changing an existing primary key value to another one is a
\&           potentially very hazardous operation and will hence be
\&           prohibited.
\&
\& Example : 
\& Returns : value of primary_key (a scalar)
\& Args    : new value (a scalar, optional)
.Ve
.SS "obj"
.IX Subsection "obj"
.Vb 3
\& Title   : obj
\& Usage   : $obj\->obj()
\& Function: Get/set the object that is made persistent through this adaptor.
\&
\&           Note that an implementation is not required to allow
\&           setting a value. In fact, an implementation is encouraged
\&           to disallow changing the value once it has been set.
\&
\&           Implementations based on inheriting from the class to be
\&           made persistent will just return $self here.
\&
\& Example : 
\& Returns : The object made persistent through this adaptor
\& Args    : On set, the new value. Read above for caveat.
.Ve
.SH "Methods for transactional control"
.IX Header "Methods for transactional control"
.Vb 1
\&   Rollback and commit
.Ve
.SS "commit"
.IX Subsection "commit"
.Vb 7
\& Title   : commit
\& Usage   :
\& Function: Commits the current transaction, if the underlying driver
\&           supports transactions.
\& Example :
\& Returns : TRUE
\& Args    : none
.Ve
.SS "rollback"
.IX Subsection "rollback"
.Vb 7
\& Title   : rollback
\& Usage   :
\& Function: Triggers a rollback of the current transaction, if the
\&           underlying driver supports transactions.
\& Example :
\& Returns : TRUE
\& Args    : none
.Ve
.SH "Decorating methods"
.IX Header "Decorating methods"
These methods aren't intrinsically necessary on this interface, but
rather ease recurrent tasks when serializing objects and translate
from object model to relational model.
.SS "rank"
.IX Subsection "rank"
.Vb 4
\& Title   : rank
\& Usage   : $obj\->rank($newval)
\& Function: Get/set the rank of this persistent object in a 1:n or n:n
\&           relationship.
\&
\&           This method is here in order to ease maintaining the order
\&           of objects in an array property or cardinality\-n
\&           association. Unless the schema mandates the corresponding
\&           attribute as NOT NULL, derived classes may override the
\&           implementation given here with an empty one.
\&
\&           In practice it may only pertain to few objects and hence
\&           could be just as well stuck onto those classes instead of
\&           also on the interface. This design decision is up for debate \-
\&           if people don\*(Aq\*(Aqt like it, it can be changed without too
\&           much effort.
\&
\& Example : 
\& Returns : value of rank (a scalar)
\& Args    : new value (a scalar or undef, optional)
.Ve
.SS "foreign_key_slot"
.IX Subsection "foreign_key_slot"
.Vb 4
\& Title   : foreign_key_slot
\& Usage   : $obj\->foreign_key_slot($newval)
\& Function: Get/set of the slot name that is referring to this persistent
\&           object as a foreign key.
\&
\&           This should come in a fully\-qualified form. The fully qualified
\&           form is the class name (or adaptor name for the class) that defines
\&           the slot, followed by a double\-colon and the name of the slot 
\&           (method) itself. I.e., it is the name of the method as class
\&           method.
\&
\&           Without this method, the name of the foreign key may be determined
\&           automatically based on naming convention, or based on a full
\&           mapping table. Neither is always possible because the situation can
\&           be ambiguous, e.g., if an entity references another instance of
\&           itself as foreign key, or if an entity references the same other
\&           entity via multiple foreign keys (e.g. entity associated to itself).
\&
\&           This method is here only to aid ferrying this value from adaptors
\&           to schema drivers and mappers who need to actually figure the
\&           name of the foreign key column in the physical schema. An adaptor
\&           is not required to use it, and everyone else other than the intended
\&           sender and recipient should know what he/she is doing before
\&           tampering with it.
\&
\& Example : 
\& Returns : value of foreign_key_slot (a scalar)
\& Args    : new value (a scalar or undef, optional)
.Ve
