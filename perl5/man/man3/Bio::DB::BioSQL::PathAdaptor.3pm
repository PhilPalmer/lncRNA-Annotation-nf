.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::BioSQL::PathAdaptor 3"
.TH Bio::DB::BioSQL::PathAdaptor 3 "2016-05-27" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::BioSQL::PathAdaptor \- DESCRIPTION of Object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Give standard usage here
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::Ontology::PathI \s-1DB\s0 adaptor
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this
and other Bioperl modules. Send your comments and suggestions preferably
 to one of the Bioperl mailing lists.
Your participation is much appreciated.
.PP
.Vb 1
\&  bioperl\-l@bio.perl.org
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
 the bugs and their resolution.
 Bug reports can be submitted via email or the web:
.PP
.Vb 2
\&  bioperl\-bugs@bioperl.org
\&  http://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Hilmar Lapp"
.IX Header "AUTHOR - Hilmar Lapp"
Email hlapp at gmx.net
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "get_persistent_slots"
.IX Subsection "get_persistent_slots"
.Vb 4
\& Title   : get_persistent_slots
\& Usage   :
\& Function: Get the slots of the object that map to attributes in its respective
\&           entity in the datastore.
\&
\&           Slots should be methods callable without an argument.
\&
\& Example :
\& Returns : an array of method names constituting the serializable slots
\& Args    : the object about to be inserted or updated
.Ve
.SS "get_persistent_slot_values"
.IX Subsection "get_persistent_slot_values"
.Vb 4
\& Title   : get_persistent_slot_values
\& Usage   :
\& Function: Obtain the values for the slots returned by get_persistent_slots(),
\&           in exactly that order.
\&
\& Example :
\& Returns : A reference to an array of values for the persistent slots of this
\&           object. Individual values may be undef.
\& Args    : The object about to be serialized.
\&           A reference to an array of foreign key objects if not retrievable 
\&           from the object itself.
.Ve
.SS "instantiate_from_row"
.IX Subsection "instantiate_from_row"
.Vb 4
\& Title   : instantiate_from_row
\& Usage   :
\& Function: Instantiates the class this object is an adaptor for, and populates
\&           it with values from columns of the row.
\&
\&           This implementation call populate_from_row() to do the real job.
\&
\&           We override this here in order to create a
\&           Bio::Ontology::Path object by default.
\&
\& Example :
\& Returns : An object, or undef, if the row contains no values
\& Args    : A reference to an array of column values. The first column
\&           is the primary key, the other columns are expected to be in
\&           the order returned by get_persistent_slots().
\&
\&           Optionally, the object factory to be used for instantiating
\&           the proper class. The adaptor must be able to instantiate a
\&           default class if this value is undef.
.Ve
.SS "populate_from_row"
.IX Subsection "populate_from_row"
.Vb 4
\& Title   : populate_from_row
\& Usage   :
\& Function: Instantiates the class this object is an adaptor for, and populates
\&           it with values from columns of the row.
\&
\& Example :
\& Returns : An object, or undef, if the row contains no values
\& Args    : The object to be populated.
\&           A reference to an array of column values. The first column is the
\&           primary key, the other columns are expected to be in the order 
\&           returned by get_persistent_slots().
.Ve
.SH "Methods specific to this adaptor"
.IX Header "Methods specific to this adaptor"
.SS "compute_transitive_closure"
.IX Subsection "compute_transitive_closure"
.Vb 5
\& Title   : compute_transitive_closure
\& Usage   :
\& Function: Compute the transitive closure over a given ontology
\&           and populate the respective path table in the relational
\&           schema.
\&
\&           There are options that allow one to create certain
\&           necessary relationships between predicates on\-the\-fly. Read
\&           below.
\&
\& Example :
\& Returns : TRUE on success, and FALSE otherwise
\& Args    : The ontology over which to create the transitive closure
\&           (a Bio::Ontology::OntologyI compliant object).
\&
\&           In addition, named parameters. Currently, the following are
\&           recognized.
\&
\&             \-truncate   If assigned a true value, will cause an existing
\&                         transitive closure for the ontology be deleted
\&                         from the path table. Usually, this option should
\&                         be enabled.
\&
\&             \-predicate_superclass A Bio::Ontology::TermI compliant object
\&                         that specifies a common ancestor predicate
\&                         for all predicates in the ontology. If this
\&                         is specified, the method will create and
\&                         serialize relationships between all
\&                         predicates in the ontology and the ancestor
\&                         predicate, where the ancestor predicate is
\&                         the object, the predicate is either the one
\&                         given by \-subclass_predicate or the term
\&                         \*(Aqimplies\*(Aq, and the ontology is the
\&                         ontology referenced by the ancestor
\&                         predicate.
\&
\&                         If this is not provided, the aforementioned
\&                         relationships should be present in an
\&                         ontology in the database already, unless the
\&                         ontology over which to compute the transitive
\&                         closure has only one predicate, or if paths
\&                         over mixed predicates are void. Otherwise the
\&                         transitive closure will not be complete for
\&                         mixed predicate paths.
\&
\&             \-subclass_predicate A Bio::Ontology::TermI compliant object
\&                         that represents the predicate for the
\&                         relationship between predicate A and
\&                         predicate B if predicate A can be considered
\&                         to subclass, or imply, predicate B.
\&
\&             \-identity_predicate A Bio::Ontology::TermI compliant object
\&                         that represents the predicate for the
\&                         identity of a predicate with itself. If
\&                         provided, the method will create
\&                         relationships for all predicates in the
\&                         ontology, where subject and object are the
\&                         predicate of the ontology, the predicate is
\&                         the supplied identity predicate, and the
\&                         ontology is the ontology referenced by the
\&                         supplied term object.
\&
\&                         If this is not provided, the aforementioned
\&                         relationships should be present in an
\&                         ontology in the database already. Otherwise the
\&                         transitive closure will be incomplete.
\&
\&                         The predicate will also be used for
\&                         indicating identity between a term and itself
\&                         for the paths of distance zero between a term
\&                         and itself. If undef the zero distance paths
\&                         will not be created.
.Ve
