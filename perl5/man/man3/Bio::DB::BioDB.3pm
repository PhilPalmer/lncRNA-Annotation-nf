.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::BioDB 3"
.TH Bio::DB::BioDB 3 "2016-05-27" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::BioDB \- class creating the adaptor factory for a particular database
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&    $dbadp = Bio::DB::BioDB\->new(
\&                                    \-database => \*(Aqbiosql\*(Aq,
\&                        \-user     => \*(Aqroot\*(Aq,
\&                        \-dbname   => \*(Aqpog\*(Aq,
\&                        \-host     => \*(Aqcaldy\*(Aq,
\&                                       \-port     => 3306,    # optional
\&                        \-driver   => \*(Aqmysql\*(Aq
\&            );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object represents a database that is implemented somehow (you
should not care much as long as you can get the object). From the
object you can pull out other adapters, such as the BioSeqAdapter etc.
.SH "CONTACT"
.IX Header "CONTACT"
.Vb 1
\&    Hilmar Lapp, hlapp at gmx.net
.Ve
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 4
\& Title   : new
\& Usage   : $db = Bio::DB::BioDB\->new(\-database => \*(Aqbiosql\*(Aq);
\& Function: Load and instantiate the encapsulating adaptor for the given
\&           database.
\&
\&           This module acts as a factory, similar in spirit to
\&           Bio::SeqIO, but instead of a sequence stream it returns the
\&           adaptor object for the specified database.
\&
\& Example :
\& Returns : a Bio::DB::DBAdaptorI implementing object
\& Args    : Named parameters. Currently recognized are
\&
\&             \-database    the name of the database for which the
\&                          encapsulating adaptor is sought (biosql|markerdb)
\&
\&             \-dbcontext   a Bio::DB::DBContextI implementing object
\&
\&             \-initrc      a scalar denoting a file which when
\&                          evaluated by perl results in a hash
\&                          reference or an array reference (to an array
\&                          with an even number of elements)
\&                          representing the arguments for this method
\&                          and for creating an instance of
\&                          Bio::DB::SimpleDBContext. The special value
\&                          DEFAULT means to use the file .bioperldb in
\&                          either the current directory or the home
\&                          directory, in this order.
\&
\&             \-printerror  whether or not the database and statement
\&                          handles to be created when necessary should
\&                          print all errors (the adaptor modules will
\&                          handle errors themselves, too)
\&
\&           Instead of \-dbcontext, you can also pass all parameters
\&           accepted by Bio::DB::SimpleDBContext::new(), and this
\&           module will create the context for you and set the
\&           dbadaptor property to the returned value. Note that if you
\&           do pass in your own DBContextI object, as a side effect the
\&           dbadaptor() property will be changed by this method to
\&           reflect the created adaptor.
\&
\&           Note also that if using the \-initrc argument any separately
\&           supplied arguments will override and supplement the
\&           arguments defined in that file.
.Ve
.SS "_load_dbadaptor"
.IX Subsection "_load_dbadaptor"
.Vb 7
\& Title   : _load_dbadaptor
\& Usage   : $self\->_load_dbadaptor("Bio::DB::BioSQL::");
\& Function: Loads up (like use) the DBAdaptorI implementing module for a
\&           database at run time on demand.
\& Example : 
\& Returns : TRUE on success
\& Args    : The prefix of the database implementing modules.
.Ve
.SS "add_db_mapping"
.IX Subsection "add_db_mapping"
.Vb 6
\& Title   : add_db_mapping
\& Usage   : $self\->add_db_mapping(key, value)
\& Function: Adds another package path mapping to the static private hash %db_map.
\& Example :  add_db_mapping("FastBioSQL", "Bio::Das::BioSQL::");
\& Returns : None
\& Args    : key \- arbitrary identifier, value \- Perl package path ending in "::"
.Ve
