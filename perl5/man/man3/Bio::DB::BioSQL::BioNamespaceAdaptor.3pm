.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::BioSQL::BioNamespaceAdaptor 3"
.TH Bio::DB::BioSQL::BioNamespaceAdaptor 3 "2016-05-27" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::BioSQL::BioNamespaceAdaptor \- DESCRIPTION of Object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Give standard usage here
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
BioNamespace \s-1DB\s0 adaptor
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 1
\&  bioperl\-l@bio.perl.org
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email
or the web:
.PP
.Vb 2
\&  bioperl\-bugs@bio.perl.org
\&  http://bio.perl.org/bioperl\-bugs/
.Ve
.SH "AUTHOR \- Hilmar Lapp"
.IX Header "AUTHOR - Hilmar Lapp"
Email hlapp at gmx.net
.PP
Based in idea on Bio:DB::BioSQL::BioDatabase by Ewan Birney,
birney@ebi.ac.uk
.PP
Describe contact details here
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 6
\& Title   : new
\& Usage   :
\& Function: Instantiates the persistence adaptor.
\& Example :
\& Returns : 
\& Args    :
.Ve
.SS "get_persistent_slots"
.IX Subsection "get_persistent_slots"
.Vb 4
\& Title   : get_persistent_slots
\& Usage   :
\& Function: Get the slots of the object that map to attributes in its respective
\&           entity in the datastore.
\&
\&           Slots should be methods callable without an argument.
\&
\&           This is a strictly abstract method. A derived class MUST override
\&           it to return something meaningful.
\& Example :
\& Returns : an array of method names constituting the serializable slots
\& Args    : the object about to be inserted or updated
.Ve
.SS "get_persistent_slot_values"
.IX Subsection "get_persistent_slot_values"
.Vb 4
\& Title   : get_persistent_slot_values
\& Usage   :
\& Function: Obtain the values for the slots returned by get_persistent_slots(),
\&           in exactly that order.
\&
\&           The reason this method is here is that sometimes the actual slot
\&           values need to be post\-processed to yield the value that gets
\&           actually stored in the database. E.g., slots holding arrays
\&           will need some kind of join function applied. Another example is if
\&           the method call needs additional arguments. Supposedly the
\&           adaptor for a specific interface knows exactly what to do here.
\&
\&           Since there is also populate_from_row() the adaptor has full
\&           control over mapping values to a version that is actually stored.
\& Example :
\& Returns : A reference to an array of values for the persistent slots of this
\&           object. Individual values may be undef.
\& Args    : The object about to be serialized.
\&           A reference to an array of foreign key objects if not retrievable 
\&           from the object itself.
.Ve
.SS "get_foreign_key_objects"
.IX Subsection "get_foreign_key_objects"
.Vb 4
\& Title   : get_foreign_key_objects
\& Usage   :
\& Function: Gets the objects referenced by this object, and which therefore need
\&           to be referenced as foreign keys in the datastore.
\&
\&           BioNamespace has no FKs, therefore this version just returns an
\&           empty array.
\& Example :
\& Returns : an array of Bio::DB::PersistentObjectI implementing objects
\& Args    : The object about to be inserted or updated.
\&           Additional arguments passed on from create().
.Ve
.SS "store_children"
.IX Subsection "store_children"
.Vb 4
\& Title   : store_children
\& Usage   :
\& Function: Inserts or updates the child entities of the given object in the 
\&           datastore.
\&
\&           BioNamespace has no children (although it is a FK for bioentries),
\&           so this version just returns TRUE.
\& Example :
\& Returns : TRUE on success, and FALSE otherwise
\& Args    : The Bio::DB::PersistentObjectI implementing object for which the
\&           child objects shall be made persistent.
.Ve
.SS "instantiate_from_row"
.IX Subsection "instantiate_from_row"
.Vb 4
\& Title   : instantiate_from_row
\& Usage   :
\& Function: Instantiates the class this object is an adaptor for, and populates
\&           it with values from columns of the row.
\&
\&           This implementation call populate_from_row() to do the real job.
\& Example :
\& Returns : An object, or undef, if the row contains no values
\& Args    : A reference to an array of column values. The first column is the
\&           primary key, the other columns are expected to be in the order 
\&           returned by get_persistent_slots().
\&           Optionally, the object factory to be used for instantiating the
\&           proper class. The adaptor must be able to instantiate a default
\&           class if this value is undef.
.Ve
.SS "populate_from_row"
.IX Subsection "populate_from_row"
.Vb 4
\& Title   : populate_from_row
\& Usage   :
\& Function: Instantiates the class this object is an adaptor for, and populates
\&           it with values from columns of the row.
\&
\&           Usually a derived class will instantiate the proper class and pass
\&           it on to populate_from_row().
\&
\&           This method MUST be overridden by a derived object.
\& Example :
\& Returns : An object, or undef, if the row contains no values
\& Args    : The object to be populated.
\&           A reference to an array of column values. The first column is the
\&           primary key, the other columns are expected to be in the order 
\&           returned by get_persistent_slots().
.Ve
.SS "get_unique_key_query"
.IX Subsection "get_unique_key_query"
.Vb 5
\& Title   : get_unique_key_query
\& Usage   :
\& Function: Obtain the suitable unique key slots and values as determined by the
\&           attribute values of the given object and the additional foreign
\&           key objects, in case foreign keys participate in a UK. 
\&
\&           This method MUST be overridden by a derived class. Alternatively,
\&           a derived class may choose to override find_by_unique_key() instead,
\&           as that one calls this method.
\& Example :
\& Returns : One or more references to hash(es) where each hash
\&           represents one unique key, and the keys of each hash
\&           represent the names of the object\*(Aqs slots that are part of
\&           the particular unique key and their values are the values
\&           of those slots as suitable for the key.
\& Args    : The object with those attributes set that constitute the chosen
\&           unique key (note that the class of the object will be suitable for
\&           the adaptor).
\&           A reference to an array of foreign key objects if not retrievable 
\&           from the object itself.
.Ve
.SS "remove_children"
.IX Subsection "remove_children"
.Vb 3
\& Title   : remove_children
\& Usage   :
\& Function: This method is to cascade deletes in maintained objects.
\&
\&           We just return TRUE here.
\&
\& Example :
\& Returns : TRUE on success and FALSE otherwise
\& Args    : The persistent object that was just removed from the database.
\&           Additional (named) parameter, as passed to remove().
.Ve
