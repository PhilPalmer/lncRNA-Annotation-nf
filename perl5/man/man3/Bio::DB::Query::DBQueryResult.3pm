.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::Query::DBQueryResult 3"
.TH Bio::DB::Query::DBQueryResult 3 "2016-05-27" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::Query::DBQueryResult \- DESCRIPTION of Object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Give standard usage here
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This modules provides an implementation of Bio::DB::Query::QueryResultI for
database queries through \s-1DBI\s0.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via
the web:
.PP
.Vb 1
\&  http://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Hilmar Lapp"
.IX Header "AUTHOR - Hilmar Lapp"
Email hlapp at gmx.net
.PP
Describe contact details here
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Additional contributors names and emails here
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 5
\& Title   : new
\& Usage   : my $obj = Bio::DB::Query::DBQueryResult\->new();
\& Function: Builds a new Bio::DB::Query::DBQueryResult object 
\& Returns : an instance of Bio::DB::Query::DBQueryResult
\& Args    : named parameters
\&
\&           \-sth        the statement handle (this object will not
\&                       execute it)
\&
\&           \-adaptor    the persistence adaptor (basically needs to 
\&                       implement instantiate_from_row($row, $factory)
\&
\&           \-factory    optionally, the object factory to pass to the
\&                       adaptor
\&
\&           \-num_fks    the number of foreign key object columns in
\&                       the rows
\&
\&           \-flat_only  whether to retrieve and attach children when
\&                       building objects (default: false)
\&
\&           If none of these are given at instantiation, at least sth() and
\&           persistence_adaptor() must be set prior to calling next_object().
.Ve
.SS "next_object"
.IX Subsection "next_object"
.Vb 6
\& Title   : next_object
\& Usage   :
\& Function: Obtain the next object from the result stream and return it.
\& Example :
\& Returns : A Bioperl object (implementing at least Bio::Root::RootI)
\& Args    : none
.Ve
.SS "each_Object"
.IX Subsection "each_Object"
.Vb 11
\& Title   : each_Object
\& Usage   :
\& Function: This is primarily a convenience method and in most implementations
\&           will just loop over next_object() and return an array of all
\&           objects.
\& Example :
\& Returns : A reference to an array of objects.
\& Args    : Optionally, an anonymous function for filtering objects. If given,
\&           the function is passed one argument, the object to evaluate.
\&           The object will be included in the returned array if the function
\&           returns TRUE, and rejected otherwise.
.Ve
.SS "finish"
.IX Subsection "finish"
.Vb 7
\& Title   : finish
\& Usage   :
\& Function: Indicate being finished with this result so that possibly used
\&           system resources can be released.
\& Example :
\& Returns : none
\& Args    : none
.Ve
.SS "sth"
.IX Subsection "sth"
.Vb 3
\& Title   : sth
\& Usage   : $obj\->sth($newval)
\& Function: Get/set statement handle from which to fetch the next row.
\&
\&           This can be changed at any time. If changed, it means the next
\&           call to next_object() will fetch from the new handle. Also, the
\&           caller needs to finish() the previous handle if necessary (i.e.,
\&           if not exhausted).
\&
\&           Note that this object will not execute the statement handle. The
\&           caller needs to ensure that has been happened until next_object()
\&           is called.
\& Example : 
\& Returns : value of sth (a DBI statement handle)
\& Args    : new value (a DBI statement handle, optional)
.Ve
.SS "persistence_adaptor"
.IX Subsection "persistence_adaptor"
.Vb 4
\& Title   : persistence_adaptor
\& Usage   : $obj\->persistence_adaptor($newval)
\& Function: Get/set the instantiation adaptor to which to delegate object
\&           instantiation from an array of row values.
\&
\&           The adaptor can be any object that implements instantiate_from_row()
\&           with two arguments, a reference to an array of column values, and
\&           optionally an object factory.
\&
\&           This can be changed at any time with no adverse side effect other
\&           than the kind of object built possibly changing.
\& Example : 
\& Returns : value of persistence_adaptor (an object)
\& Args    : new value (an object, optional)
.Ve
.SS "object_factory"
.IX Subsection "object_factory"
.Vb 3
\& Title   : object_factory
\& Usage   : $obj\->object_factory($newval)
\& Function: Get/set the object factory to pass to the instantiation adaptor.
\&
\&           Setting this is optional because providing it to the instantiation
\&           adaptor is optional.
\& Example : 
\& Returns : value of object_factory (a Bio::Factory::ObjectFactoryI compliant
\&           instance)
\& Args    : new value (a Bio::Factory::ObjectFactoryI compliant
\&           instance, optional)
.Ve
.SS "num_fks"
.IX Subsection "num_fks"
.Vb 3
\& Title   : num_fks
\& Usage   : $obj\->num_fks($newval)
\& Function: Get/set the number of foreign key columns in a given result row.
\&
\&           Setting this correctly is only important for query results for which
\&           the resulting objects must have the foreign key objects attached.
\& Example : 
\& Returns : value of num_fks (a scalar)
\& Args    : new value (a scalar, optional)
.Ve
.SS "flat_retrieval"
.IX Subsection "flat_retrieval"
.Vb 4
\& Title   : flat_retrieval
\& Usage   : $obj\->flat_retrieval($newval)
\& Function: Get/set whether objects should be retrieved and built flat
\&           or with all their dependent objects fetched and attached.
\&
\&           The default is to build full objects with all children
\&           attached which provides for no bad surprises when
\&           inspecting the results. However, building flat objects by
\&           disregarding children is potentially a lot faster, so this
\&           option is useful if, for instance, for a sequence you don\*(Aqt
\&           need any annotation or features.
\&
\& Example : 
\& Returns : value of flat_retrieval (a scalar evaluating to true or false)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
